#!/usr/bin/python3
# -*- coding: utf-8 -*-

import os, sys, shutil, subprocess, collections, time, datetime, shlex

class OrigFile():
	def __init__(self, inode1,inode2, path,type,date,size,perms):
		self.path = path
		self.i1 = inode1
		self.i2 = inode2
		self.type = type
		self.date = date.split(".")[0] #truncate date to seconds
		self.size = size
		self.perms = perms

class DirFile():
	def __init__(self, inode, path, type, date, size, perms):
		self.i = inode
		self.path = path
		self.type = type
		self.date = date
		self.size = size
		self.perms = perms

def samefiles(f1, f2):
	# only take size in account for regular files
	if f1.type == "f" and f2.type == "f":
		return f1.date==f2.date and f1.perms==f2.perms and f1.size==f2.size
	else:
		return f1.type==f2.type and f1.date==f2.date and f1.perms==f2.perms

# http://stackoverflow.com/questions/9237246/python-how-to-read-file-with-nul-delimited-lines
# http://bugs.python.org/issue1152248
def fileLineIter(inputFile,
                 inputNewline="\n",
                 outputNewline=None,
                 readSize=8192):
   """Like the normal file iter but you can set what string indicates newline.

   The newline string can be arbitrarily long; it need not be restricted to a
   single character. You can also set the read size and control whether or not
   the newline string is left on the end of the iterated lines.  Setting
   newline to '\0' is particularly good for use with an input file created with
   something like "os.popen('find -print0')".
   """
   if outputNewline is None: outputNewline = inputNewline
   partialLine = ''
   while True:
       charsJustRead = inputFile.read(readSize)
       if not charsJustRead: break
       partialLine += charsJustRead
       lines = partialLine.split(inputNewline)
       partialLine = lines.pop()
       for line in lines: yield line + outputNewline.rstrip('\0') # little mod
   if partialLine: yield partialLine.rstrip('\0') # little mod

def ssh_master_init(sshlogin):
	import tempfile, atexit
	tmpdir = tempfile.mkdtemp()
	sshsock = os.path.join(tmpdir, "bsync_%r@%h:%p")
	atexit.register(ssh_master_clean, tmpdir, sshsock, sshlogin)
	subprocess.check_call(["ssh", "-fNMS", sshsock, sshlogin])
	return sshsock

def ssh_master_clean(tmpdir, sshsock, sshlogin):
	# send exit signal to ssh master, this will remove the socket
	subprocess.call(["ssh", "-S", sshsock, "-Oexit", sshlogin])
	try:
		os.rmdir(tmpdir) # remove tmpdir (should be empty)
	except OSError:
		time.sleep(0.5)
		try:
			os.rmdir(tmpdir)
		except:
			pass

findformat = "%i\\0%P\\0%y\\0%T@\\0%s\\0%#m\\0"
# find test1/ -printf "%i\t%P\t%y\t%T@\t%s\t%#m\n"

def ssh_shell_init(sshsock, sshlogin):
	return subprocess.Popen([ "ssh", "-S"+sshsock, sshlogin, "sh -e" ], stdin=subprocess.PIPE, universal_newlines=True)

def rsync_init(sshsock, sshloginSrc,dirnameSrc, sshloginDst,dirnameDst):
	#rsync ssh/dir1 --> local/dir2
	#rsync local/dir1 --> ssh/dir2
	#
	#rsync ssh/dir2 --> local/dir1
	#rsync local/dir2 --> ssh/dir1
	if sshloginSrc == None:
		rsyncsrc = dirnameSrc+"/"
	else:
		rsyncsrc = sshloginSrc+":"+dirnameSrc+"/"

	if sshloginDst == None:
		rsyncdst = dirnameDst+"/"
	else:
		rsyncdst = sshloginDst+":"+dirnameDst+"/"

	if sshsock == None: sshsock = ""
	return subprocess.Popen([ "rsync", "-a", "-e ssh -S"+sshsock, "--files-from=-", "--from0", "--no-implied-dirs", rsyncsrc, rsyncdst ], stdin=subprocess.PIPE, universal_newlines=True)

# TODO arguments and escapes...
# snap format: inode, path, type, date
def make_snapshot(sshsock, sshlogin,dirname, oldsnapname, newsnapname):
	global findformat

	cmd = "find %s -fprintf %s '%s'" % (dirname, dirname+"/"+newsnapname, findformat)
	if oldsnapname!=None:
		cmd+= " && rm -f "+dirname+"/"+oldsnapname

	if sshlogin==None:
		subprocess.check_call(cmd, shell=True)
	else:
		subprocess.check_call([ "ssh", "-S"+sshsock, sshlogin, cmd])

def get_find_fd(sshsock, sshlogin, dirname):
	global findformat
	if sshlogin==None:
		return subprocess.Popen([ "find", dirname, "-printf", findformat ], stdout=subprocess.PIPE, universal_newlines=True).stdout
	else:
		#print(subprocess.Popen([ "ssh", "-S"+sshsock, sshlogin, "find "+dirname+" -printf "+findformat ], stdout=subprocess.PIPE, universal_newlines=True).communicate()[0])
		return subprocess.Popen([ "ssh", "-S"+sshsock, sshlogin, "find "+dirname+" -printf '"+findformat+"'" ], stdout=subprocess.PIPE, universal_newlines=True).stdout

def get_snap_fd(sshsock, sshlogin, dirname, snapname):
	if sshlogin==None:
		return open(dirname+"/"+snapname, "r")
	else:
		return subprocess.Popen([ "ssh", "-S"+sshsock, sshlogin, "cat "+dirname+"/"+snapname ], stdout=subprocess.PIPE, universal_newlines=True).stdout

def get_snap_fileset(sshsock, sshlogin,dirname):
	snaps = set()
	if sshlogin==None:
		try:
			for f in os.listdir(dirname):
				if f.startswith(".bsync-snap-"):
					snaps.add(f)
		except:
			sys.exit("Error: could not open directory: "+dirname)
	else:
		try:
			out = subprocess.check_output([ "ssh", "-S"+sshsock, sshlogin, "cd "+dirname+" && ( ls -1 .bsync-snap-* 2>/dev/null || true )" ], universal_newlines=True)
		except subprocess.CalledProcessError:
			sys.exit("Error: could not open remote directory: "+dirname)
		
		snaps = set( out.split("\n") )
	return snaps

def load_orig(sshsock, sshlogin1,dir1name, sshlogin2,dir2name):
	dir1snaps = get_snap_fileset(sshsock, sshlogin1,dir1name)
	dir2snaps = get_snap_fileset(sshsock, sshlogin2,dir2name)

	common_snaps = dir1snaps.intersection(dir2snaps)
	
	orig = collections.OrderedDict()
	if len(common_snaps) == 0:
		print("Warning: could not find snap files. Starting from empty history.")
		return (None, orig) #empty snap and orig

	snapname = max(common_snaps) #the most recent snapshot

	fd1 = get_snap_fd(sshsock, sshlogin1, dir1name, snapname)
	fd2 = get_snap_fd(sshsock, sshlogin2, dir2name, snapname)

	gen1 = fileLineIter(fd1, inputNewline='\0')
	gen2 = fileLineIter(fd2, inputNewline='\0')

	# iterate on gen1 to fill orig
	# first fill with 1st .snap, then with 2nd .snap, because the order can be different (find output)
	while True:
		i=p=t=d=s=perms=None
		try:
			i,p,t,d,s,perms = next(gen1),next(gen1),next(gen1),next(gen1),next(gen1),next(gen1)
		except StopIteration:
			if i==None and p==None and t==None and d==None and s==None and perms==None:
				break
			else:
				sys.exit("Error: snap filelists not coherent.")

		if not p.startswith(".bsync-snap-"):
			d = d.split(".")[0]	# truncate date to seconds
			if t=="d": d="0"	# ignore dates for dirs
			orig[p] = OrigFile(i,None, p,t,d,s,perms)

	# iterate on gen2, fill inodes for dir2 and check for consistency
	while True:
		i=p=t=d=s=perms=None
		try:
			i,p,t,d,s,perms = next(gen2),next(gen2),next(gen2),next(gen2),next(gen2),next(gen2)
		except StopIteration:
			if i==None and p==None and t==None and d==None and s==None and perms==None:
				break
			else:
				sys.exit("Error: snap filelists not coherent.")

		if not p.startswith(".bsync-snap-"):
			d = d.split(".")[0]	# truncate date to seconds
			if t=="d": d="0"	# ignore dates for dirs

			origfile = orig[p]
			if not p in orig:
				sys.exit("Error: missing path in dir2: "+p)
			if origfile.type != t or origfile.date != d or origfile.size != s or origfile.perms != perms:
				sys.exit("Error: difference in snaps for path: "+p) 

			origfile.i2 = i

	fd1.close()
	fd2.close()

	return (snapname, orig)

def load_dir(sshsock, sshlogin, dirname):
	dir = collections.OrderedDict()

	fd = get_find_fd(sshsock, sshlogin, dirname)

	gen1 = fileLineIter(fd, inputNewline='\0')

	while True:
		i=p=t=d=s=perms=None
		try:
			i,p,t,d,s,perms = next(gen1),next(gen1),next(gen1),next(gen1),next(gen1),next(gen1)
		except StopIteration:
			if i==None and p==None and t==None and d==None and s==None and perms==None:
				break
			else:
				sys.exit("Error: problem in find output")

		d = d.split(".")[0] #truncate date to seconds

		if not p.startswith(".bsync-snap-"):
			if t=="d": d="0"
			dir[p] = DirFile(i, p, t, d, s, perms)
	
	fd.close()
	
	return dir

def ask_conflict(f1, f2, path):
	p1=p2=""
	if f1 == None:
		p1 = "*deleted*"
	else:
		d1 = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime( int(f1.date.split(".")[0]) ))
		p1 = path+" ("+d1+")"
	if f2 == None:
		p2 = "*deleted*"
	else:
		d2 = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime( int(f2.date.split(".")[0]) ))
		p2 = path+" ("+d2+")"
	print_action("conflict", p1, "???", p2)
	resp = "invalid"
	while resp != "1" and resp != "2":
		resp = input("Which change do I keep [1|2]: ")
	return resp

#### file actions
def remove(shproc, path):
	global realrun
	if not realrun: return

	if shproc == None:
		os.remove(path)
	else:
		shproc.stdin.write("rm "+shlex.quote(path)+"\n")
		shproc.stdin.flush()

def removedir(shproc, path):
	global realrun
	if not realrun: return

	if shproc == None:
		try:
			os.rmdir(path)
		except OSError as e:
			#pass
			print("Warning: "+str(e)) # can happen: dir removed in 1, file dir/f added in 2
	else:
		shproc.stdin.write("rmdir "+shlex.quote(path)+" || true\n")
		shproc.stdin.flush()

# TODO security for shell injection
def mkdir(shproc, path, perms):
	global realrun
	if not realrun: return

	if shproc == None:
		os.mkdir(path, int(perms, 8) )
	else:
		shproc.stdin.write("mkdir -m"+perms+" "+shlex.quote(path)+"\n")
		shproc.stdin.flush()

def move(shproc, src, dst, perms):
	global realrun
	if not realrun: return

	if shproc == None:
		os.rename(src, dst)
		if perms!=None:
			os.chmod(dst, int(perms, 8) )
	else:
		shproc.stdin.write("mv "+shlex.quote(src)+" "+shlex.quote(dst)+"\n")
		if perms!=None:
			shproc.stdin.write("chmod "+perms+" "+shlex.quote(dst)+"\n")
		shproc.stdin.flush()

def sync_local(p1, p2): ## finish that ... use rsync
	# possible cases with files/dirs : d>d d>f f>f f>d d>_ f>_
	# d>d rien
	# d>f rm p2, mkdir p2
	# f>f copy2 p1 p2
	# f>d rmdir p2, copy2 p1 p2
	# d>_ mkdir p2
	# f>_ copy2 p1 p2
	global realrun
	if not realrun: return
		
	if os.path.isdir(p1):
		if not os.path.isdir(p2):
			if os.path.exists(p2):
				os.remove(p2)
			os.makedirs(p2)
		shutil.copystat(p1, p2)
	else: #p1 is a file (maybe not a regular file)
		if os.path.isdir(p2):
			try:
				os.rmdir(p2) # fails when dir not empty
			except OSError as e:
				print("Warning: "+str(e))
				return
		
		d = os.path.dirname(p2)
		if not os.path.isdir(d):
			os.makedirs(d)

		shutil.copy2(p1, p2)

def rsync(rsyncproc, path):
	global realrun
	if not realrun: return
	rsyncproc.stdin.write(path+"\0")
	rsyncproc.stdin.flush()

def print_action(action, path1, arrow, path2):
	print( path1.ljust(30) +" "+arrow+"  "+ path2.ljust(30) +"("+action+")" )

def print_files(fo, f1, f2):
	return
	print("%s: i:%s d:%s | i:%s d:%s (orig)" % (fo.path, fo.i1, fo.date, fo.i2, fo.date))
	f1str = f1str = "i:"+f1.i+" d:"+str(f1.date) if f1!=None else ""
	f2str = f2str = "i:"+f2.i+" d:"+str(f2.date) if f2!=None else ""
	print("%s: %s | %s" % (fo.path, f1str, f2str))

def print_files12(path, f1, f2):
	return
	f1str = f1str = "i:"+f1.i+" d:"+str(f1.date) if f1!=None else ""
	f2str = f2str = "i:"+f2.i+" d:"+str(f2.date) if f2!=None else ""
	print("%s: %s | %s" % (path, f1str, f2str))

def do_actions(dirnum, sshsock,
	sshlogin1,dir1name, sshlogin2,dir2name,
	mkdirs, copy, rm, rmdirs, sync
	):
	global realrun

	##### actions involving one side
	sshlogin = sshlogin2
	arrow = "-->"
	if dirnum==1:
		sshlogin = sshlogin1
		arrow = "<--"

	shproc = None
	# if we need a ssh shell
	if ( (dirnum==2 and sshlogin2!=None) or (dirnum==1 and sshlogin1!=None) ) \
	   and ( mkdirs!=[] or copy!=[] or rmdirs!=[] or len(rm)!=0 ) and realrun:
		shproc = ssh_shell_init(sshsock, sshlogin)

	# mkdirss must be done before
	os.umask(0000) #disable umask to allow for any mkdirs
	for f in mkdirs:
		if dirnum==2:
			print_action("mkdir", f.path+"/", "-->", "")
			mkdir(shproc, dir2name+"/"+f.path, f.perms)
		else:
			print_action("mkdir", "", "<--", f.path+"/")
			mkdir(shproc, dir1name+"/"+f.path, f.perms)

	# check if we can move, else copy
	copyreal = []
	for fsrc in copy: # f1 in copy12
		# we must copy f1 to dir2
		# to use a move: search for f1 inode
		# f1.i == fo.i1 <> fo.i2 == f2.i
		fcandidate = rm.pop(fsrc.i, None) # check if we can use a move

		# check date to be sure that no change on file.
		if fcandidate != None and fcandidate.type == fsrc.type and fcandidate.date == fsrc.date and fcandidate.size == fsrc.size:
			perms = None if fcandidate.perms == fsrc.perms else fsrc.perms
			if dirnum==2:
				print_action("move", fsrc.path, "-->", "from:"+fcandidate.path)
				move(shproc, dir2name+"/"+fcandidate.path, dir2name+"/"+fsrc.path, perms)
			else:
				print_action("move", "from:"+fcandidate.path, "<--", fsrc.path)
				move(shproc, dir1name+"/"+fcandidate.path, dir1name+"/"+fsrc.path, perms)
		else:	
			copyreal.append(fsrc.path)
	# removes, after the check moves step
	for f in rm.values():
		if dirnum==2:
			print_action("rm", "", "-->", f.path)
			remove(shproc, dir2name+"/"+f.path)
		else:
			print_action("rm", f.path, "<--", "")
			remove(shproc, dir1name+"/"+f.path)

	# rmdirs must be done after
	rmdirs.sort(reverse=True) # TODO someth cleaner than sort?
	for path in rmdirs:
		if dirnum==2:
			print_action("rmdir", "", "-->", path)
			removedir(shproc, dir2name+"/"+path)
		else:
			print_action("rmdir", path, "<--", "")
			removedir(shproc, dir1name+"/"+path)

	if shproc != None:
		shproc.stdin.close()
		shproc.wait() # wait shell process to exit

	##### actions involving a transfer
	rsyncproc = None
	# if we need rsync (at least one remote dir, and some copies/sync to do)
	if ( copyreal!=[] or sync!=[] ) and realrun:
		if dirnum==2:
			rsyncproc = rsync_init(sshsock, sshlogin1,dir1name, sshlogin2,dir2name)
		else:
			rsyncproc = rsync_init(sshsock, sshlogin2,dir2name, sshlogin1,dir1name)

	# finish with copy and sync
	for path in copyreal:
		if dirnum==2:
			print_action("copy", path, "-->", "")
		else:
			print_action("copy", "", "<--", path)
		rsync(rsyncproc, path)
	for path in sync:
		if dirnum==2:
			print_action("sync", path, "-->", path)
		else:
			print_action("sync", path, "<--", path)
		rsync(rsyncproc, path)

	if rsyncproc != None:
		rsyncproc.stdin.close()
		rsyncproc.wait()
# end do_actions

##############
if len(sys.argv) != 4:
	sys.exit("Syntax: "+sys.argv[0]+" DIR1 DIR2 -rn")

dir1name = sys.argv[1]
dir2name = sys.argv[2]
realrun = True if sys.argv[3] == "-r" else False

# get sshlogin vars
sshlogin1 = sshlogin2 = None
if ':' in dir1name:
	sshlogin1, dir1name = dir1name.split(':', 1)
if ':' in dir2name:
	sshlogin2, dir2name = dir2name.split(':', 1)
if sshlogin1!=None and sshlogin2!=None:
	sys.exit("Error: only one remote directory supported.")

sshsock = None
if sshlogin1!=None or sshlogin2!=None:
	sshlogin = sshlogin1 if sshlogin1!=None else sshlogin2
	sshsock = ssh_master_init(sshlogin)

print("Loading original filelist from .snap files...")
snapname, origlist = load_orig(sshsock, sshlogin1,dir1name, sshlogin2,dir2name)

print("Loading dir1 filelist...")
dir1 = load_dir(sshsock, sshlogin1, dir1name)
print("Loading dir2 filelist...")
dir2 = load_dir(sshsock, sshlogin2, dir2name)

mkdir1 = []
mkdir2 = []
rmdirs1 = []
rmdirs2 = []
rm1 = collections.OrderedDict()
rm2 = collections.OrderedDict()
copy12 = []
copy21 = []
sync12 = []
sync21 = []

print("Analysing original paths...")
# process all paths from snapshot
for path, fo in origlist.items():
	# f1==None f2==None				deleted both sides
	# f1==None f2=!None f2.d==fo.d			f1 chg only
	# f1==None f2=!None f2.d!=fo.d			conflict
	# f1!=None f2==None f1.d==fo.d			f2 chg only
	# f1!=None f2==None f1.d!=fo.d			conflict
	# f1!=None f2!=None f1.d==fo.d f2.d==fo.d	no change
	# f1!=None f2!=None f1.d==fo.d f2.d!=fo.d	f2 chg only
	# f1!=None f2!=None f1.d!=fo.d f2.d==fo.d	f1 chg only
	# f1!=None f2!=None f1.d!=fo.d f2.d!=fo.d	conflict

	f1 = dir1[path] if path in dir1 else None
	f2 = dir2[path] if path in dir2 else None

	print_files(fo, f1, f2)

	if f1 == None and f2 == None:
		# deleted both sides --> nothing to do
		pass
	elif f1 != None and f2 != None and samefiles(f1,f2):
		# same file contents --> nothing to do
		pass
	elif f2 != None and samefiles(f2,fo):
		# no f2 change --> f1 change only
		if f1 == None:
			# f1 deleted --> delete f2
			if f2.type == "d": # f2 isdir
				rmdirs2.append(path)
			else:
				rm2[fo.i1] = f2
		else:
			# f1 != None and f1 != fo.date --> f1 mod --> mod f2
			sync12.append(path)
	elif f1 != None and samefiles(f1,fo):
		# no f1 change --> f2 change only
		if f2 == None:
			if f1.type == "d": #f1 isdir
				rmdirs1.append(path)
			else:
				rm1[fo.i2] = f1
		else:
			sync21.append(path)
	else:
		# f1 change and f2 change --> confict
		# f1 != None and f2 != None --> f1.date != f2.date (!= fo.date)
		# f1 == None and f2 != None
		# f1 != None and f2 == None

		tokeep = ask_conflict(f1, f2, path);
		if tokeep == "1":
			if f1 == None:
				if f2.type == "d": # f2 isdir
					rmdirs2.append(path)
				else:
					rm2[fo.i1] = f2
			else:
				if f2 == None:
					if f1.type == "d":
						mkdir2.append(f1)
					else:
						copy12.append(f1)
				else:
					sync12.append(path)
		else: # tokeep == 2
			if f2 == None:
				if f1.type == "d": # f1 isdir
					rmdirs1.append(path)
				else:
					rm1[fo.i2] = f1
			else:
				if f1 == None:
					if f2.type == "d":
						mkdir1.append(f2)
					else:
						copy21.append(f2)
				else:
					sync21.append(path)
	#ifend

	dir1.pop(path, None)
	dir2.pop(path, None)
#forend

print("Analysing remaining new paths in dir1...")
# process new paths in dir1
for path, f1 in dir1.items():
	f2 = dir2[path] if path in dir2 else None

	print_files12(path, f1, f2)
	
	if f2 != None and samefiles(f2,f1):
		# f1 and f2 added but same files --> nothing to do
		pass
	elif f2 == None:
		# adding in d2
		if f1.type == "d":
			mkdir2.append(f1)
		else:
			copy12.append(f1)
	else:
		# f2!=None and f2.date != f1.date --> conflict
		tokeep = ask_conflict(f1, f2, path);
		if tokeep == "1":
			sync12.append(path)
		else: # tokeep == 2
			sync21.append(path)

	dir2.pop(path, None)

print("Analysing remaining new paths in dir2...")
# process remaining new paths in dir2
for path, f2 in dir2.items():
	f1 = dir1[path] if path in dir1 else None

	print_files12(path, f1, f2)
	
	if f1 != None and samefiles(f1,f2):
		pass
	elif f1 == None:
		if f2.type == "d":
			mkdir1.append(f2)
		else:
			copy21.append(f2)
	else:
		tokeep = ask_conflict(f1, f2, path);
		if tokeep == "1":
			sync12.append(path)
		else: # tokeep == 2
			sync21.append(path)

# ACTION!

print("Applying actions in dir2...")
# ACTIONS in dir2 -->
do_actions(2, sshsock,
	sshlogin1,dir1name, sshlogin2,dir2name,
	mkdir2, copy12, rm2, rmdirs2, sync12
	)

print("Applying actions in dir1...")
# ACTIONS in dir1 <--
do_actions(1, sshsock,
	sshlogin1,dir1name, sshlogin2,dir2name,
	mkdir1, copy21, rm1, rmdirs1, sync21
	)

if realrun:
	print("Updating .snap files...")
	newsnapname = ".bsync-snap-"+datetime.datetime.now().strftime("%Y%m%d%H%M%S.%f")
	make_snapshot(sshsock, sshlogin1,dir1name, snapname,newsnapname)
	make_snapshot(sshsock, sshlogin2,dir2name, snapname,newsnapname)
