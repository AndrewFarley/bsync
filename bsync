#!/usr/bin/python3
# -*- coding: utf-8 -*-

import os, sys, shutil, subprocess, collections, time, shlex

class OrigFile():
	def __init__(self, inode1,inode2, path,type,date):
		self.path = path
		self.i1 = inode1
		self.i2 = inode2
		self.date = date.split(".")[0] #truncate date to seconds
		self.type = type

# http://stackoverflow.com/questions/9237246/python-how-to-read-file-with-nul-delimited-lines
# http://bugs.python.org/issue1152248
def fileLineIter(inputFile,
                 inputNewline="\n",
                 outputNewline=None,
                 readSize=8192):
   """Like the normal file iter but you can set what string indicates newline.

   The newline string can be arbitrarily long; it need not be restricted to a
   single character. You can also set the read size and control whether or not
   the newline string is left on the end of the iterated lines.  Setting
   newline to '\0' is particularly good for use with an input file created with
   something like "os.popen('find -print0')".
   """
   if outputNewline is None: outputNewline = inputNewline
   partialLine = ''
   while True:
       charsJustRead = inputFile.read(readSize)
       if not charsJustRead: break
       partialLine += charsJustRead
       lines = partialLine.split(inputNewline)
       partialLine = lines.pop()
       for line in lines: yield line + outputNewline.rstrip('\0') # little mod
   if partialLine: yield partialLine.rstrip('\0') # little mod

def ssh_master_init(sshlogin):
	import tempfile, atexit
	tmpdir = tempfile.mkdtemp()
	sshsock = os.path.join(tmpdir, "bsync_%r@%h:%p")
	atexit.register(ssh_master_clean, tmpdir, sshsock, sshlogin)
	subprocess.check_call(["ssh", "-fNMS", sshsock, sshlogin])
	return sshsock

def ssh_master_clean(tmpdir, sshsock, sshlogin):
	# send exit signal to ssh master, this will remove the socket
	subprocess.call(["ssh", "-S", sshsock, "-Oexit", sshlogin])
	os.rmdir(tmpdir) # remove tmpdir (should be empty)

findformat = "%i\\0%P\\0%y\\0%T@\\0"
# find test1/ -printf "%i\t%P\t%y\t%T@\n"

def ssh_shell_init(sshsock, sshlogin):
	return subprocess.Popen([ "ssh", "-S"+sshsock, sshlogin, "sh -e" ], stdin=subprocess.PIPE, universal_newlines=True)

def rsync_init(sshsock, sshloginSrc,dirnameSrc, sshloginDst,dirnameDst):
	#rsync ssh/dir1 --> local/dir2
	#rsync local/dir1 --> ssh/dir2
	#
	#rsync ssh/dir2 --> local/dir1
	#rsync local/dir2 --> ssh/dir1
	if sshloginSrc == None:
		rsyncsrc = dirnameSrc+"/"
		rsyncdst = sshloginDst+":"+dirnameDst+"/"
	else: # sshloginDst == None
		rsyncsrc = sshloginSrc+":"+dirnameSrc+"/"
		rsyncdst = dirnameDst+"/"

	return subprocess.Popen([ "rsync", "-a", "-e ssh -S"+sshsock, "--files-from=-", "--from0", "--no-implied-dirs", rsyncsrc, rsyncdst ], stdin=subprocess.PIPE, universal_newlines=True)

# snap format: inode, path, type, date
def make_snapshot(sshsock, sshlogin1,dir1name, sshlogin2,dir2name):
	global findformat
	if sshlogin1==None:
		subprocess.check_call([ "find", dir1name, "-fprintf", dir1name+"/.snap", findformat ])
	else:
		subprocess.check_call([ "ssh", "-S"+sshsock, sshlogin1, "find", dir1name, "-fprintf", dir1name+"/.snap", "'"+findformat+"'" ])
	if sshlogin2==None:
		subprocess.check_call([ "find", dir2name, "-fprintf", dir2name+"/.snap", findformat ])
	else:
		subprocess.check_call([ "ssh", "-S"+sshsock, sshlogin2, "find", dir2name, "-fprintf", dir2name+"/.snap", "'"+findformat+"'" ])

def get_find_fd(sshsock, sshlogin, dirname):
	global findformat
	if sshlogin==None:
		return subprocess.Popen([ "find", dirname, "-printf", findformat ], stdout=subprocess.PIPE, universal_newlines=True).stdout
	else:
		#print(subprocess.Popen([ "ssh", "-S"+sshsock, sshlogin, "find "+dirname+" -printf "+findformat ], stdout=subprocess.PIPE, universal_newlines=True).communicate()[0])
		return subprocess.Popen([ "ssh", "-S"+sshsock, sshlogin, "find "+dirname+" -printf '"+findformat+"'" ], stdout=subprocess.PIPE, universal_newlines=True).stdout

def get_snap_fd(sshsock, sshlogin, dirname):
	if sshlogin==None:
		if os.path.isfile(dirname+"/.snap"):
			return open(dirname+"/.snap", "r")
		else:
			return None
	else:
		if subprocess.call([ "ssh", "-S"+sshsock, sshlogin, "test -f "+dirname+"/.snap"]) == 0:
			return subprocess.Popen([ "ssh", "-S"+sshsock, sshlogin, "cat "+dirname+"/.snap" ], stdout=subprocess.PIPE, universal_newlines=True).stdout
		else:
			return None

def load_orig(sshsock, sshlogin1,dir1name, sshlogin2,dir2name):
	orig = collections.OrderedDict()

	fd1 = get_snap_fd(sshsock, sshlogin1, dir1name)
	fd2 = get_snap_fd(sshsock, sshlogin2, dir2name)

	if fd1==None or fd2==None:
		return orig #empty orig

	gen1 = fileLineIter(fd1, inputNewline='\0')
	gen2 = fileLineIter(fd2, inputNewline='\0')

	# iterate on gen1 to fill orig
	# first fill with 1st .snap, then with 2nd .snap, because the order can be different (find output)
	while True:
		i=p=t=d=None
		try:
			i,p,t,d = next(gen1),next(gen1),next(gen1),next(gen1)
		except StopIteration:
			if i==None and p==None and t==None and d==None:
				break
			else:
				sys.exit("Error: .snap filelists not coherent.")

		if p!=".snap":
			d = d.split(".")[0]	# truncate date to seconds
			if t=="d": d="0"	# ignore dates for dirs
			orig[p] = OrigFile(i,None, p,t,d)

	# iterate on gen2, fill inodes for dir2 and check for consistency
	while True:
		i=p=t=d=None
		try:
			i,p,t,d = next(gen2),next(gen2),next(gen2),next(gen2)
		except StopIteration:
			if i==None and p==None and t==None and d==None:
				break
			else:
				sys.exit("Error: .snap filelists not coherent.")

		if p!=".snap":
			d = d.split(".")[0]	# truncate date to seconds
			if t=="d": d="0"	# ignore dates for dirs

			origfile = orig[p]
			if not p in orig:
				sys.exit("Error: missing path in dir2: "+p)

			if origfile.type != t or origfile.date != d:
				sys.exit("Error: difference in .snap for path: "+p)

			origfile.i2 = i

	fd1.close()
	fd2.close()

	return orig

class DirFile():
	def __init__(self, inode, path, type, date):
		self.i = inode
		self.path = path
		self.type = type
		self.date = date

def load_dir(sshsock, sshlogin, dirname):
	dir = collections.OrderedDict()

	fd = get_find_fd(sshsock, sshlogin, dirname)

	gen1 = fileLineIter(fd, inputNewline='\0')

	while True:
		i1=p1=t1=d1=None
		try:
			i1,p1,t1,d1 = next(gen1),next(gen1),next(gen1),next(gen1)
		except StopIteration:
			if i1==None and p1==None and t1==None and d1==None:
				break
			else:
				sys.exit("Error: problem in find output")

		d1 = d1.split(".")[0] #truncate date to seconds

		if p1!=".snap":
			if t1=="d": d1="0"
			dir[p1] = DirFile(i1, p1, t1, d1)
	
	fd.close()
	
	return dir

def ask_conflict(f1, f2, path):
	p1=p2=""
	if f1 == None:
		p1 = "*deleted*"
	else:
		d1 = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime( int(f1.date.split(".")[0]) ))
		p1 = path+" ("+d1+")"
	if f2 == None:
		p2 = "*deleted*"
	else:
		d2 = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime( int(f2.date.split(".")[0]) ))
		p2 = path+" ("+d2+")"
	print_action("conflict", p1, "???", p2)
	resp = "invalid"
	while resp != "1" and resp != "2":
		resp = input("Which change do I keep [1|2]: ")
	return resp

#### file actions
def remove(shproc, path):
	global realrun
	if not realrun: return

	if shproc == None:
		os.remove(path)
	else:
		shproc.stdin.write("rm "+shlex.quote(path)+"\n")
		shproc.stdin.flush()

def removedir(shproc, path):
	global realrun
	if not realrun: return

	if shproc == None:
		try:
			os.rmdir(path)
		except OSError as e:
			#pass
			print("Warning: "+str(e)) # can happen: dir removed in 1, file dir/f added in 2
	else:
		shproc.stdin.write("rmdir "+shlex.quote(path)+" || true\n")
		shproc.stdin.flush()

def mkdir(shproc, path):
	global realrun
	if not realrun: return

	if shproc == None:
		os.mkdir(path)
	else:
		shproc.stdin.write("mkdir "+shlex.quote(path)+"\n")
		shproc.stdin.flush()

def move(shproc, src, dst):
	global realrun
	if not realrun: return

	if shproc == None:
		os.rename(src, dst)
	else:
		shproc.stdin.write("mv "+shlex.quote(src)+" "+shlex.quote(dst)+"\n")
		shproc.stdin.flush()

def sync_local(p1, p2):
	# possible cases with files/dirs : d>d d>f f>f f>d d>_ f>_
	# d>d rien
	# d>f rm p2, mkdir p2
	# f>f copy2 p1 p2
	# f>d rmdir p2, copy2 p1 p2
	# d>_ mkdir p2
	# f>_ copy2 p1 p2
	global realrun
	if not realrun: return
		
	if os.path.isdir(p1):
		if not os.path.isdir(p2):
			if os.path.exists(p2):
				os.remove(p2)
			os.makedirs(p2)
	else: #p1 is a file (maybe not a regular file)
		if os.path.isdir(p2):
			try:
				os.rmdir(p2) # fails when dir not empty
			except OSError as e:
				print("Warning: "+str(e))
				return
		
		d = os.path.dirname(p2)
		if not os.path.isdir(d):
			os.makedirs(d)

		shutil.copy2(p1, p2)

def sync_remote(rsyncproc, path):
	global realrun
	if not realrun: return
	rsyncproc.stdin.write(path+"\0")
	rsyncproc.stdin.flush()

def print_action(action, path1, arrow, path2):
	print( path1.ljust(30) +" "+arrow+"  "+ path2.ljust(30) +"("+action+")" )

def print_files(fo, f1, f2):
	return
	print("%s: i:%s d:%s | i:%s d:%s (orig)" % (fo.path, fo.i1, fo.date, fo.i2, fo.date))
	f1str = f1str = "i:"+f1.i+" d:"+str(f1.date) if f1!=None else ""
	f2str = f2str = "i:"+f2.i+" d:"+str(f2.date) if f2!=None else ""
	print("%s: %s | %s" % (fo.path, f1str, f2str))

def print_files12(path, f1, f2):
	return
	f1str = f1str = "i:"+f1.i+" d:"+str(f1.date) if f1!=None else ""
	f2str = f2str = "i:"+f2.i+" d:"+str(f2.date) if f2!=None else ""
	print("%s: %s | %s" % (path, f1str, f2str))

def do_actions(dirnum, sshsock,
	sshlogin1,dir1name, sshlogin2,dir2name,
	mkdirs, copy, rm, rmdirs, sync
	):
	global realrun

	##### actions involving one side
	sshlogin = sshlogin2
	arrow = "-->"
	if dirnum==1:
		sshlogin = sshlogin1
		arrow = "<--"

	shproc = None
	# if we need a ssh shell
	if ( (dirnum==2 and sshlogin2!=None) or (dirnum==1 and sshlogin1!=None) ) \
	   and ( mkdirs!=[] or copy!=[] or rmdirs!=[] or len(rm)!=0 ) and realrun:
		shproc = ssh_shell_init(sshsock, sshlogin)

	# mkdirss must be done before
	for path in mkdirs:
		if dirnum==2:
			print_action("mkdir", path+"/", "-->", "")
			mkdir(shproc, dir2name+"/"+path)
		else:
			print_action("mkdir", "", "<--", path+"/")
			mkdir(shproc, dir1name+"/"+path)

	# check if we can move, else copy
	copyreal = []
	for fsrc in copy: # f1 in copy12
		# we must copy f1 to dir2
		# to use a move: search for f1 inode
		# f1.i == fo.i1 <> fo.i2 == f2.i
		fcandidate = rm.pop(fsrc.i, None) # check if we can use a move

		# check date to be sure that no change on file. TODO check size also
		if fcandidate != None and fcandidate.date == fsrc.date:
			if dirnum==2:
				print_action("move", fsrc.path, "-->", "from:"+fcandidate.path)
				move(shproc, dir2name+"/"+fcandidate.path, dir2name+"/"+fsrc.path)
			else:
				print_action("move", "from:"+fcandidate.path, "<--", fsrc.path)
				move(shproc, dir1name+"/"+fsrc.path, dir1name+"/"+fcandidate.path)
		else:	
			copyreal.append(fsrc.path)
	# removes, after the check moves step
	for f in rm.values():
		if dirnum==2:
			print_action("rm", "", "-->", f.path)
			remove(shproc, dir2name+"/"+f.path)
		else:
			print_action("rm", f.path, "<--", "")
			remove(shproc, dir1name+"/"+f.path)

	# rmdirs must be done after
	rmdirs.sort(reverse=True) # TODO someth cleaner than sort?
	for path in rmdirs:
		if dirnum==2:
			print_action("rmdir", "", "-->", path)
			removedir(shproc, dir2name+"/"+path)
		else:
			print_action("rmdir", path, "<--", "")
			removedir(shproc, dir1name+"/"+path)

	if shproc != None:
		shproc.stdin.close()
		shproc.wait() # wait shell process to exit

	##### actions involving a transfer
	rsyncproc = None
	# if we need rsync (at least one remote dir, and some copies/sync to do)
	if (sshlogin2!=None or sshlogin1!=None) and ( copyreal!=[] or sync!=[] ) and realrun:
		if dirnum==2:
			rsyncproc = rsync_init(sshsock, sshlogin1,dir1name, sshlogin2,dir2name)
		else:
			rsyncproc = rsync_init(sshsock, sshlogin2,dir2name, sshlogin1,dir1name)

	# finish with copy and sync
	for path in copyreal:
		if dirnum==2:
			print_action("copy", path, "-->", "")
			if rsyncproc == None:
				sync_local(dir1name+"/"+path, dir2name+"/"+path)
			else:
				sync_remote(rsyncproc, path)
		else:
			print_action("copy", "", "<--", path)
			if rsyncproc == None:
				sync_local(dir2name+"/"+path, dir1name+"/"+path)
			else:
				sync_remote(rsyncproc, path)
	for path in sync:
		if dirnum==2:
			print_action("sync", path, "-->", path)
			if rsyncproc == None:
				sync_local(dir1name+"/"+path, dir2name+"/"+path)
			else:
				sync_remote(rsyncproc, path)
		else:
			print_action("sync", path, "<--", path)
			if rsyncproc == None:
				sync_local(dir2name+"/"+path, dir1name+"/"+path)
			else:
				sync_remote(rsyncproc, path)

	if rsyncproc != None:
		rsyncproc.stdin.close()
		rsyncproc.wait()
# end do_actions

##############
if len(sys.argv) != 4:
	sys.exit("Syntax: "+sys.argv[0]+" DIR1 DIR2 -rn")

dir1name = sys.argv[1]
dir2name = sys.argv[2]
realrun = True if sys.argv[3] == "-r" else False

# get sshlogin vars
sshlogin1 = sshlogin2 = None
if ':' in dir1name:
	sshlogin1, dir1name = dir1name.split(':', 1)
if ':' in dir2name:
	sshlogin2, dir2name = dir2name.split(':', 1)
if sshlogin1!=None and sshlogin2!=None:
	sys.exit("Error: only one remote directory supported.")

sshsock = None
if sshlogin1!=None or sshlogin2!=None:
	sshlogin = sshlogin1 if sshlogin1!=None else sshlogin2
	sshsock = ssh_master_init(sshlogin)

print("Loading original filelist from .snap files...")
origlist = load_orig(sshsock, sshlogin1,dir1name, sshlogin2,dir2name)

if len(origlist) == 0:
	print("Warning: could not find .snap files. Starting from empty history.")

#print(origlist)

print("Loading dir1 filelist...")
dir1 = load_dir(sshsock, sshlogin1, dir1name)
print("Loading dir2 filelist...")
dir2 = load_dir(sshsock, sshlogin2, dir2name)

mkdir1 = []
mkdir2 = []
rmdirs1 = []
rmdirs2 = []
rm1 = collections.OrderedDict()
rm2 = collections.OrderedDict()
copy12 = []
copy21 = []
sync12 = []
sync21 = []

print("Analysing original paths...")
# process all paths from snapshot
for path, fo in origlist.items():
	# f1==None f2==None				deleted both sides
	# f1==None f2=!None f2.d==fo.d			f1 chg only
	# f1==None f2=!None f2.d!=fo.d			conflict
	# f1!=None f2==None f1.d==fo.d			f2 chg only
	# f1!=None f2==None f1.d!=fo.d			conflict
	# f1!=None f2!=None f1.d==fo.d f2.d==fo.d	no change
	# f1!=None f2!=None f1.d==fo.d f2.d!=fo.d	f2 chg only
	# f1!=None f2!=None f1.d!=fo.d f2.d==fo.d	f1 chg only
	# f1!=None f2!=None f1.d!=fo.d f2.d!=fo.d	conflict

	f1 = dir1[path] if path in dir1 else None
	f2 = dir2[path] if path in dir2 else None

	print_files(fo, f1, f2)

	if f1 == None and f2 == None:
		# deleted both sides --> nothing to do
		pass
	elif f1 != None and f2 != None and f1.date == f2.date:
		# same file contents --> nothing to do
		pass
	elif f2 != None and f2.date == fo.date:
		# no f2 change --> f1 change only
		if f1 == None:
			# f1 deleted --> delete f2
			if f2.date == "0": # f2 isdir
				rmdirs2.append(path)
			else:
				rm2[fo.i1] = f2
		else:
			# f1 != None and f1 != fo.date --> f1 mod --> mod f2
			sync12.append(path)
	elif f1 != None and f1.date == fo.date:
		# no f1 change --> f2 change only
		if f2 == None:
			if f1.date == "0": #f1 isdir
				rmdirs1.append(path)
			else:
				rm1[fo.i2] = f1
		else:
			sync21.append(path)
	else:
		# f1 change and f2 change --> confict
		# f1 != None and f2 != None --> f1.date != f2.date (!= fo.date)
		# f1 == None and f2 != None
		# f1 != None and f2 == None

		tokeep = ask_conflict(f1, f2, path);
		if tokeep == "1":
			if f1 == None:
				if f2.date == "0": # f2 isdir
					rmdirs2.append(path)
				else:
					rm2[fo.i1] = f2
			else:
				if f2 == None:
					if f1.date == "0":
						mkdir2.append(path)
					else:
						copy12.append(f1)
				else:
					sync12.append(path)
		else: # tokeep == 2
			if f2 == None:
				if f1.date == "0": # f1 isdir
					rmdirs1.append(path)
				else:
					rm1[fo.i2] = f1
			else:
				if f1 == None:
					if f2.date == "0":
						mkdir1.append(path)
					else:
						copy21.append(f2)
				else:
					sync21.append(path)
	#ifend

	dir1.pop(path, None)
	dir2.pop(path, None)
#forend

print("Analysing remaining new paths in dir1...")
# process new paths in dir1
for path, f1 in dir1.items():
	f2 = dir2[path] if path in dir2 else None

	print_files12(path, f1, f2)
	
	if f2 != None and f2.date == f1.date:
		# f1 and f2 added but same files --> nothing to do
		pass
	elif f2 == None:
		# adding in d2
		if f1.date == "0":
			mkdir2.append(path)
		else:
			copy12.append(f1)
	else:
		# f2!=None and f2.date != f1.date --> conflict
		tokeep = ask_conflict(f1, f2, path);
		if tokeep == "1":
			sync12.append(path)
		else: # tokeep == 2
			sync21.append(path)

	dir2.pop(path, None)

print("Analysing remaining new paths in dir2...")
# process remaining new paths in dir2
for path, f2 in dir2.items():
	f1 = dir1[path] if path in dir1 else None

	print_files12(path, f1, f2)
	
	if f1 != None and f1.date == f2.date:
		pass
	elif f1 == None:
		if f2.date == "0":
			mkdir1.append(path)
		else:
			copy21.append(f2)
	else:
		tokeep = ask_conflict(f1, f2, path);
		if tokeep == "1":
			sync12.append(path)
		else: # tokeep == 2
			sync21.append(path)

# ACTION!

print("Applying actions in dir2...")
# ACTIONS in dir2 -->
do_actions(2, sshsock,
	sshlogin1,dir1name, sshlogin2,dir2name,
	mkdir2, copy12, rm2, rmdirs2, sync12
	)

print("Applying actions in dir1...")
# ACTIONS in dir1 <--
do_actions(1, sshsock,
	sshlogin1,dir1name, sshlogin2,dir2name,
	mkdir1, copy21, rm1, rmdirs1, sync21
	)

if realrun:
	print("Updating .snap files...")
	make_snapshot(sshsock, sshlogin1,dir1name, sshlogin2,dir2name)
