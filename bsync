#!/usr/bin/python3
# -*- coding: utf-8 -*-

import os, sys, shutil, subprocess, collections, time

class OrigFile():
	def __init__(self, inode1,inode2, path,type,date):
		self.path = path
		self.i1 = inode1
		self.i2 = inode2
		self.date = date
		self.type = type

# http://stackoverflow.com/questions/9237246/python-how-to-read-file-with-nul-delimited-lines
# http://bugs.python.org/issue1152248
def fileLineIter(inputFile,
                 inputNewline="\n",
                 outputNewline=None,
                 readSize=8192):
   """Like the normal file iter but you can set what string indicates newline.

   The newline string can be arbitrarily long; it need not be restricted to a
   single character. You can also set the read size and control whether or not
   the newline string is left on the end of the iterated lines.  Setting
   newline to '\0' is particularly good for use with an input file created with
   something like "os.popen('find -print0')".
   """
   if outputNewline is None: outputNewline = inputNewline
   partialLine = ''
   while True:
       charsJustRead = inputFile.read(readSize)
       if not charsJustRead: break
       partialLine += charsJustRead
       lines = partialLine.split(inputNewline)
       partialLine = lines.pop()
       for line in lines: yield line + outputNewline.rstrip('\0') # little mod
   if partialLine: yield partialLine.rstrip('\0') # little mod

def ssh_master_init(sshlogin):
	import tempfile, atexit
	tmpdir = tempfile.mkdtemp()
	sshsock = os.path.join(tmpdir, "bsync_%r@%h:%p")
	atexit.register(ssh_master_clean, tmpdir, sshsock, sshlogin)
	subprocess.check_call(["ssh", "-fNMS", sshsock, sshlogin])
	return sshsock

def ssh_master_clean(tmpdir, sshsock, sshlogin):
	# send exit signal to ssh master, this will remove the socket
	subprocess.call(["ssh", "-S", sshsock, "-Oexit", sshlogin])
	os.rmdir(tmpdir) # remove tmpdir (should be empty)

findformat = "%i\\0%P\\0%y\\0%T@\\0"

# snap format: inode, path, type, date
def make_snapshot(dir1name, dir2name):
	global findformat
	subprocess.check_call([ "find", dir1name, "-fprintf", dir1name+"/.snap", findformat ])
	subprocess.check_call([ "find", dir2name, "-fprintf", dir2name+"/.snap", findformat ])

def get_find_fd(sshsock, sshlogin, dirname):
	global findformat
	if sshlogin==None:
		return subprocess.Popen([ "find", dirname, "-printf", findformat ], stdout=subprocess.PIPE, universal_newlines=True).stdout
	else:
		#print(subprocess.Popen([ "ssh", "-S"+sshsock, sshlogin, "find "+dirname+" -printf "+findformat ], stdout=subprocess.PIPE, universal_newlines=True).communicate()[0])
		return subprocess.Popen([ "ssh", "-S"+sshsock, sshlogin, "find "+dirname+" -printf '"+findformat+"'" ], stdout=subprocess.PIPE, universal_newlines=True).stdout

def get_snap_fd(sshsock, sshlogin, dirname):
	if sshlogin==None:
		if os.path.isfile(dirname+"/.snap"):
			return open(dirname+"/.snap", "r")
		else:
			return None
	else:
		if subprocess.call([ "ssh", "-S"+sshsock, sshlogin, "test -f "+dirname+"/.snap"]) == 0:
			return subprocess.Popen([ "ssh", "-S"+sshsock, sshlogin, "cat "+dirname+"/.snap" ], stdout=subprocess.PIPE, universal_newlines=True).stdout
		else:
			return None

def load_orig(sshsock, sshlogin1,dir1name, sshlogin2,dir2name):

	fd1 = get_snap_fd(sshsock, sshlogin1, dir1name)
	fd2 = get_snap_fd(sshsock, sshlogin2, dir2name)
	#print(fd1)
	#print(fd2)

	if fd1==None or fd2==None:
		return []

	gen1 = fileLineIter(fd1, inputNewline='\0')
	gen2 = fileLineIter(fd2, inputNewline='\0')

	orig = []

	while True:
		i1=p1=t1=d1 = i2=p2=t2=d2=None
		try:
			i1,p1,t1,d1 = next(gen1),next(gen1),next(gen1),next(gen1)
			i2,p2,t2,d2 = next(gen2),next(gen2),next(gen2),next(gen2)
		except StopIteration:
			# if all values are empty in the same time: ok, we reached
			# end of files 
			if ( i1==None and p1==None and t1==None and d1==None
			 and i2==None and p2==None and t2==None and d2==None ):
				break
			else:
				sys.exit("Error: .snap filelists not coherent")

		if p1!=".snap":
			# ignore dates for dirs
			if t1=="d": d1="0"
			if t2=="d": d2="0"
			if p1!=p2 or t1!=t2 or d1!=d2:
				sys.exit("Error: difference in .snap for path: '"+p1+"'")

			orig.append( OrigFile(i1,i2, p1,t1,d1) )

	fd1.close()
	fd2.close()

	return orig

class DirFile():
	def __init__(self, inode, path, type, date):
		self.i = inode
		self.path = path
		self.type = type
		self.date = date

def load_dir(sshsock, sshlogin, dirname):
	dir = collections.OrderedDict()

	fd = get_find_fd(sshsock, sshlogin, dirname)

	gen1 = fileLineIter(fd, inputNewline='\0')

	while True:
		i1=p1=t1=d1=None
		try:
			i1,p1,t1,d1 = next(gen1),next(gen1),next(gen1),next(gen1)
		except StopIteration:
			if i1==None and p1==None and t1==None and d1==None:
				break
			else:
				sys.exit("Error: problem in find output")

		if p1!=".snap":
			if t1=="d": d1="0"
			dir[p1] = DirFile(i1, p1, t1, d1)
	
	fd.close()
	
	return dir

def ask_conflict(f1, f2, path):
	p1=p2=""
	if f1 != None:
		d1 = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime( int(f1.date.split(".")[0]) ))
		p1 = path+" ("+d1+")"
	if f2 != None:
		d2 = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime( int(f2.date.split(".")[0]) ))
		p2 = path+" ("+d2+")"
	print_action("conflict", p1, "???", p2)
	resp = "invalid"
	while resp != "1" and resp != "2":
		resp = input("File to keep [1|2]: ")
	return resp

def remove(path):
	global realrun
	if not realrun: return

	os.remove(path)

#### file actions
def removedir(path):
	global realrun
	if not realrun: return
	try:
		os.rmdir(path)
	except OSError as e:
		print("Warning: "+str(e))

def mkdir(path):
	global realrun
	if not realrun: return
	os.mkdir(path)

def sync(p1, p2):
	# possible cases with files/dirs : d>d d>f f>f f>d d>_ f>_
	# d>d rien
	# d>f rm p2, mkdir p2
	# f>f copy2 p1 p2
	# f>d rmdir p2, copy2 p1 p2
	# d>_ mkdir p2
	# f>_ copy2 p1 p2
	global realrun
	if not realrun: return
		
	if os.path.isdir(p1):
		if not os.path.isdir(p2):
			if os.path.exists(p2):
				os.remove(p2)
			os.makedirs(p2)
	else: #p1 is a file (maybe not a regular file)
		if os.path.isdir(p2):
			try:
				os.rmdir(p2) # fails when dir not empty
			except OSError as e:
				print("Warning: "+str(e))
				return
		
		d = os.path.dirname(p2)
		if not os.path.isdir(d):
			os.makedirs(d)

		shutil.copy2(p1, p2)

def move(src, dst):
	global realrun
	if not realrun: return
	os.rename(src, dst)

def print_action(action, path1, arrow, path2):
	print( path1.ljust(30) +" "+arrow+"  "+ path2.ljust(30) +"("+action+")" )

def print_files(fo, f1, f2):
	return
	print("%s: i:%s d:%s | i:%s d:%s (orig)" % (fo.path, fo.i1, fo.date, fo.i2, fo.date))
	f1str = f1str = "i:"+f1.i+" d:"+str(f1.date) if f1!=None else ""
	f2str = f2str = "i:"+f2.i+" d:"+str(f2.date) if f2!=None else ""
	print("%s: %s | %s" % (fo.path, f1str, f2str))

def print_files12(path, f1, f2):
	return
	f1str = f1str = "i:"+f1.i+" d:"+str(f1.date) if f1!=None else ""
	f2str = f2str = "i:"+f2.i+" d:"+str(f2.date) if f2!=None else ""
	print("%s: %s | %s" % (path, f1str, f2str))

##############
if len(sys.argv) != 4:
	sys.exit("Syntax: "+sys.argv[0]+" DIR1 DIR2 -rn")

dir1name = sys.argv[1]
dir2name = sys.argv[2]
realrun = True if sys.argv[3] == "-r" else False

# get sshlogin vars
sshlogin1 = sshlogin2 = None
if ':' in dir1name:
	sshlogin1, dir1name = dir1name.split(':', 1)
if ':' in dir2name:
	sshlogin2, dir2name = dir2name.split(':', 1)
if sshlogin1!=None and sshlogin2!=None:
	sys.exit("Error: only one remote directory supported.")

sshsock = None
if sshlogin1!=None or sshlogin2!=None:
	sshlogin = sshlogin1 if sshlogin1!=None else sshlogin2
	sshsock = ssh_master_init(sshlogin)

origlist = load_orig(sshsock, sshlogin1,dir1name, sshlogin2,dir2name)

if origlist == []:
	print("Warning: could not find .snap files. Starting from empty history.")

#print(origlist)

dir1 = load_dir(sshsock, sshlogin1, dir1name)
dir2 = load_dir(sshsock, sshlogin2, dir2name)

mkdir1 = []
mkdir2 = []
rmdirs1 = []
rmdirs2 = []
rm1 = collections.OrderedDict()
rm2 = collections.OrderedDict()
copy12 = []
copy21 = []
sync12 = []
sync21 = []

# process all paths from snapshot
for fo in origlist:
	# f1==None f2==None				deleted both sides
	# f1==None f2=!None f2.d==fo.d			f1 chg only
	# f1==None f2=!None f2.d!=fo.d			conflict
	# f1!=None f2==None f1.d==fo.d			f2 chg only
	# f1!=None f2==None f1.d!=fo.d			conflict
	# f1!=None f2!=None f1.d==fo.d f2.d==fo.d	no change
	# f1!=None f2!=None f1.d==fo.d f2.d!=fo.d	f2 chg only
	# f1!=None f2!=None f1.d!=fo.d f2.d==fo.d	f1 chg only
	# f1!=None f2!=None f1.d!=fo.d f2.d!=fo.d	conflict

	path = fo.path
	
	f1 = dir1[path] if path in dir1 else None
	f2 = dir2[path] if path in dir2 else None

	print_files(fo, f1, f2)

	if f1 == None and f2 == None:
		# deleted both sides --> nothing to do
		pass
	elif f1 != None and f2 != None and f1.date == f2.date:
		# same file contents --> nothing to do
		pass
	elif f2 != None and f2.date == fo.date:
		# no f2 change --> f1 change only
		if f1 == None:
			# f1 deleted --> delete f2
			if f2.date == "0": # f2 isdir
				rmdirs2.append(path)
			else:
				rm2[fo.i1] = f2
		else:
			# f1 != None and f1 != fo.date --> f1 mod --> mod f2
			sync12.append(path)
	elif f1 != None and f1.date == fo.date:
		# no f1 change --> f2 change only
		if f2 == None:
			if f1.date == "0": #f1 isdir
				rmdirs1.append(path)
			else:
				rm1[fo.i2] = f1
		else:
			sync21.append(path)
	else:
		# f1 change and f2 change --> confict
		# f1 != None and f2 != None --> f1.date != f2.date (!= fo.date)
		# f1 == None and f2 != None
		# f1 != None and f2 == None

		tokeep = ask_conflict(f1, f2, path);
		if tokeep == "1":
			if f1 == None:
				if f2.date == "0": # f2 isdir
					rmdirs2.append(path)
				else:
					rm2[fo.i1] = f2
			else:
				if f2 == None:
					if f1.date == "0":
						mkdir2.append(path)
					else:
						copy12.append(f1)
				else:
					sync12.append(path)
		else: # tokeep == 2
			if f2 == None:
				if f1.date == "0": # f1 isdir
					rmdirs1.append(path)
				else:
					rm1[fo.i2] = f1
			else:
				if f1 == None:
					if f2.date == "0":
						mkdir1.append(path)
					else:
						copy21.append(f2)
				else:
					sync21.append(path)
	#ifend

	dir1.pop(path, None)
	dir2.pop(path, None)
#forend

# process new paths in dir1
for path, f1 in dir1.items():
	f2 = dir2[path] if path in dir2 else None

	print_files12(path, f1, f2)
	
	if f2 != None and f2.date == f1.date:
		# f1 and f2 added but same files --> nothing to do
		pass
	elif f2 == None:
		# adding in d2
		if f1.date == "0":
			mkdir2.append(path)
		else:
			copy12.append(f1)
	else:
		# f2!=None and f2.date != f1.date --> conflict
		tokeep = ask_conflict(f1, f2, path);
		if tokeep == "1":
			sync12.append(path)
		else: # tokeep == 2
			sync21.append(path)

	dir2.pop(path, None)

# process remaining new paths in dir2
for path, f2 in dir2.items():
	f1 = dir1[path] if path in dir1 else None

	print_files12(path, f1, f2)
	
	if f1 != None and f1.date == f2.date:
		pass
	elif f1 == None:
		if f2.date == "0":
			mkdir1.append(path)
		else:
			copy21.append(f2)
	else:
		tokeep = ask_conflict(f1, f2, path);
		if tokeep == "1":
			sync12.append(path)
		else: # tokeep == 2
			sync21.append(path)

# ACTION!

####################
# ACTIONS in dir2

# mkdirs must be done before
for path in mkdir2:
	print_action("mkdir", path+"/", "-->", "")
	mkdir(dir2name+"/"+path)

# check if we can move, else copy
copyreal12 = []
for f1 in copy12:
	# we must copy f1 to dir2
	# to use a move: search for f1 inode
	# f1.i == fo.i1 <> fo.i2 == f2.i
	f2src = rm2.pop(f1.i, None) # check if we can use a move

	# check date to be sure that no change on file. TODO check size also
	if f2src != None and f2src.date == f1.date:
		print_action("move", f1.path, "-->", "from:"+f2src.path)
		move(dir2name+"/"+f2src.path, dir2name+"/"+f1.path)
	else:	
		copyreal12.append(f1.path)
# removes, after the check moves step
for f in rm2.values():
	print_action("rm", "", "-->", f.path)
	remove(dir2name+"/"+f.path)

# rmdirs must be done after
rmdirs2.sort(reverse=True)
for path in rmdirs2:
	print_action("rmdir", "", "-->", path)
	removedir(dir2name+"/"+path)

# finish with copy and sync
for path in copyreal12:
	print_action("copy", path, "-->", "")
	sync(dir1name+"/"+path, dir2name+"/"+path)
for path in sync12:
	print_action("sync", path, "-->", path)
	sync(dir1name+"/"+path, dir2name+"/"+path)

####################
# ACTIONS in dir1

# mkdirs must be done before
for path in mkdir1:
	print_action("mkdir", "", "<--", path+"/")
	mkdir(dir1name+"/"+path)

# check if we can move, else copy
copyreal21 = []
for f2 in copy21:
	f1src = rm1.pop(f2.i, None) # check if we can use a move
	# check date to be sure that no change on file. TODO check size also
	if f1src != None and f1src.date == f2.date:
		print_action("move", "from:"+f1src.path, "<--", f2.path)
		move(dir1name+"/"+f1src.path, dir1name+"/"+f2.path)
	else:	
		copyreal21.append(f2.path)
# removes, after the check moves step
for f in rm1.values():
	print_action("rm", f.path, "<--", "")
	remove(dir1name+"/"+f.path)

# rmdirs must be done after
rmdirs1.sort(reverse=True)
for path in rmdirs1:
	print_action("rmdir", path, "<--", "")
	removedir(dir1name+"/"+path)

# finish with copy and sync
for path in copyreal21:
	print_action("copy", "", "<--", path)
	sync(dir2name+"/"+path, dir1name+"/"+path)
for path in sync21:
	print_action("sync", path, "<--", path)
	sync(dir2name+"/"+path, dir1name+"/"+path)


#===========

if realrun:
	make_snapshot(dir1name, dir2name)
