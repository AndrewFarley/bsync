#!/usr/bin/python3
# -*- coding: utf-8 -*-

import os, sys, shutil, subprocess, collections

class OrigFile():
	def __init__(self, path, inode1, inode2, date):
		self.path = path
		self.i1 = inode1
		self.i2 = inode2
		self.date = date

def make_snapshot(dir1name, dir2name):
	fd1 = open(dir1name+"/.snaptmp", "w")
	fd2 = open(dir2name+"/.snaptmp", "w")

	for root, dirs, files in os.walk(dir1name):
		for f in files:
			path = root+"/"+f
			path = os.path.relpath(path, dir1name)
			if path == ".snap" or path == ".snaptmp": continue
			stat1 = os.stat(dir1name+"/"+path)
			stat2 = os.stat(dir2name+"/"+path)
			
			if str(stat1.st_mtime) != str(stat2.st_mtime):
				sys.exit("Error making snap: different mtimes for "+path)

			fd1.write(path+"\t"+str(stat1.st_ino)+"\t"+str(stat1.st_mtime)+"\n")
			fd2.write(path+"\t"+str(stat2.st_ino)+"\t"+str(stat2.st_mtime)+"\n")
	fd1.close()
	fd2.close()

	os.rename(dir1name+"/.snaptmp", dir1name+"/.snap")
	os.rename(dir2name+"/.snaptmp", dir2name+"/.snap")

def load_orig(dir1name, dir2name):
	orig = []

	if os.path.isfile(dir1name+"/.snap") and os.path.isfile(dir2name+"/.snap"):
		fd1 = open(dir1name+"/.snap", "r")
		fd2 = open(dir2name+"/.snap", "r")
		
		line1 = fd1.readline().rstrip("\n")
		line2 = fd2.readline().rstrip("\n")

		while line1 != "" and line2 != "":

			p1, i1, d1 = line1.split("\t")
			p2, i2, d2 = line2.split("\t")
			if p1 != p2 or d1 != d2:
				sys.exit("Error: difference in .snap")

			orig.append( OrigFile(p1, i1, i2, d1) )

			line1 = fd1.readline().rstrip("\n")
			line2 = fd2.readline().rstrip("\n")

		if line1 != "" or line2 != "":
			sys.exit("Error: .snap filelists are different.")

		fd1.close()
		fd2.close()

	return orig

class DirFile():
	def __init__(self, inode, date):
		self.i = inode
		self.date = date

def load_dir(dirname):
	dir = collections.OrderedDict()
	for root, dirs, files in os.walk(dirname):
		for f in files:
			path = root+"/"+f
			stat = os.stat(path)
			path = os.path.relpath(path, dirname)
			if path == ".snap" or path == ".snaptmp": continue
			dir[path] = DirFile(str(stat.st_ino), str(stat.st_mtime))
	return dir

def ask_conflict(f1, f2, path):
	print(path+" <?> "+path)
	resp = "invalid"
	while resp != "1" and resp != "2":
		resp = raw_input("File to keep [1|2]: ")
	return resp

def remove(path):
	global realrun
	if realrun:
		os.remove(path)

def sync(p1, p2):
	global realrun
	if realrun:
		d = os.path.dirname(p2)
		if not os.path.isdir(d):
			os.makedirs(d)
		shutil.copy2(p1, p2)

def print_action(action, path1, arrow, path2):
	print( path1.ljust(30) +" "+arrow+"  "+ path2.ljust(30) +"("+action+")" )

def print_files(fo, f1, f2):
	return
	print("%s: i:%s d:%s | i:%s d:%s (orig)" % (fo.path, fo.i1, fo.date, fo.i2, fo.date))
	f1str = f1str = "i:"+f1.i+" d:"+str(f1.date) if f1!=None else ""
	f2str = f2str = "i:"+f2.i+" d:"+str(f2.date) if f2!=None else ""
	print("%s: %s | %s" % (fo.path, f1str, f2str))

def print_files12(path, f1, f2):
	return
	f1str = f1str = "i:"+f1.i+" d:"+str(f1.date) if f1!=None else ""
	f2str = f2str = "i:"+f2.i+" d:"+str(f2.date) if f2!=None else ""
	print("%s: %s | %s" % (path, f1str, f2str))

##############
if len(sys.argv) != 4:
	print("Syntax: "+sys.argv[0]+" DIR1 DIR2 -rn")
	sys.exit()

dir1name = sys.argv[1]
dir2name = sys.argv[2]
realrun = True if sys.argv[3] == "-r" else False

origlist = load_orig(dir1name, dir2name)

dir1 = load_dir(dir1name)
dir2 = load_dir(dir2name)

# process all paths from snapshot
for fo in origlist:
	# f1==None f2==None				deleted both sides
	# f1==None f2=!None f2.d==fo.d			f1 chg only
	# f1==None f2=!None f2.d!=fo.d			conflict
	# f1!=None f2==None f1.d==fo.d			f2 chg only
	# f1!=None f2==None f1.d!=fo.d			conflict
	# f1!=None f2!=None f1.d==fo.d f2.d==fo.d	no change
	# f1!=None f2!=None f1.d==fo.d f2.d!=fo.d	f2 chg only
	# f1!=None f2!=None f1.d!=fo.d f2.d==fo.d	f1 chg only
	# f1!=None f2!=None f1.d!=fo.d f2.d!=fo.d	conflict

	path = fo.path
	
	f1 = dir1[path] if path in dir1 else None
	f2 = dir2[path] if path in dir2 else None

	print_files(fo, f1, f2)

	if f1 == None and f2 == None:
		# deleted both sides --> nothing to do
		pass
	elif f1 != None and f2 != None and f1.date == f2.date:
		# same file contents --> nothing to do
		pass
	elif f2 != None and f2.date == fo.date:
		# no f2 change --> f1 change only
		if f1 == None:
			# f1 deleted --> delete f2
			print_action("rm", "", "-->", path)
			remove(dir2name+"/"+path)
		else:
			# f1 != None and f1 != fo.date --> f1 mod --> mod f2
			print_action("sync", path, "-->", path)
			sync(dir1name+"/"+path, dir2name+"/"+path)
	elif f1 != None and f1.date == fo.date:
		# no f1 change --> f2 change only
		if f2 == None:
			print_action("rm", path, "<--", path)
			remove(dir1name+"/"+path)
		else:
			print_action("sync", path, "<--", path)
			sync(dir2name+"/"+path, dir1name+"/"+path)
	else:
		# f1 change and f2 change --> confict
		# f1 != None and f2 != None --> f1.date != f2.date (!= fo.date)
		# f1 == None and f2 != None
		# f1 != None and f2 == None

		tokeep = ask_conflict(f1, f2, path);
		if tokeep == "1":
			if f1 == None:
				print_action("rm", "", "-->", path)
				remove(dir2name+"/"+path)
			else:
				print_action("sync", path, "-->", path if f2!=None else "")
				sync(dir1name+"/"+path, dir2name+"/"+path)
		else: # tokeep == 2
			if f2 == None:
				print_action("rm", path, "<--", "")
				remove(dir1name+"/"+path)
			else:
				print_action("sync", path if f1!=None else "", "<--", path)
				sync(dir2name+"/"+path, dir1name+"/"+path)
	#ifend

	dir1.pop(path, None)
	dir2.pop(path, None)
#forend

# process new paths in dir1
for path, f1 in dir1.items():
	f2 = dir2[path] if path in dir2 else None

	print_files12(path, f1, f2)
	
	if f2 != None and f2.date == f1.date:
		# f1 and f2 added but same files --> nothing to do
		pass
	elif f2 == None:
		# adding in d2
		print_action("sync", path, "-->", "")
		sync(dir1name+"/"+path, dir2name+"/"+path)
	else:
		# f2!=None and f2.date != f1.date --> conflict

		tokeep = ask_conflict(f1, f2, path);
		if tokeep == "1":
			print_action("sync", path, "-->", path)
			sync(dir1name+"/"+path, dir2name+"/"+path)
		else: # tokeep == 2
			print_action("sync", path, "<--", path)
			sync(dir2name+"/"+path, dir1name+"/"+path)

	dir2.pop(path, None)

# process remaining new paths in dir2
for path, f2 in dir2.items():
	f1 = dir1[path] if path in dir1 else None

	print_files12(path, f1, f2)
	
	if f1 != None and f1.date == f2.date:
		pass
	elif f1 == None:
		print_action("sync", "", "<-->", path)
		sync(dir2name+"/"+path, dir1name+"/"+path)
	else:
		tokeep = ask_conflict(f1, f2, path);
		if tokeep == "1":
			print_action("sync", path, "-->", path)
			sync(dir1name+"/"+path, dir2name+"/"+path)
		else: # tokeep == 2
			print_action("sync", path, "<--", path)
			sync(dir2name+"/"+path, dir1name+"/"+path)

if realrun:
	make_snapshot(dir1name, dir2name)
